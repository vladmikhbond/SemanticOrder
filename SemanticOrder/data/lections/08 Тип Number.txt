@1 08 Тип Number

@3 Всі числа зберігаються за стандартом IEEE-754 - «double precision»
[[ieee-754.png]]

@3 Це пояснює, чому
{{
> 0.1 + 0.2 == 0.3
false
}}

@3 Записувати числа можна в десятковому або 16-річній с.с. або в експоненційній формі.
{{
> 255
> 0xFF
> 3e-4
}}


@3 Для розпізнавання чисел Infinity та NaN передбачені спеціальні функції isFinite(n) та isNaN(n).

@3 У JS арифметичні операції можна робити не тільки над числами.
У цьому разі інші типи неявно перетворюються на числа.
{{
> +"123"
> true - false
> -"wau"
}}

@3 Явне перетворення виконує функція Number (без new)
{{
> Number(true)
1
}}

@3 Перетворити число в рядок може метод toString()
{{
> (255).toString()
> (255).toString(16)
> (255).toString(8)
> (35).toString(36)
}}
або toLocaleString()
{{
> (123456789).toLocaleString()
}}

@3 Перетворення на рядок із округленням робить метод toFixed.
{{
> (3.14159).toFixed(3)
}}

@3 Розбір рядків, що містять запис не тільки числа (таких як "10pt" або "-12px"), виконують функції parseInt(s) та parseFloat(s).
{{
alert( parseInt('12pt') )
}}

@3 Математичні функції зібрані в об'єкті Math.

@2 Методи простих типів

@3 Прості типи створюють менше навантаження на пам'ять і обчислення з ними відбуваються швидше.
З іншого боку, хотілося б щоб вони мали властивості і методи, це зручно для програмування.

@3 Щоб сумістити несумісне, створюється об'єкт-обгортка, який надає потрібні речі, а потім видаляється.

@3 Типи обгорток різні і відповідають примітивам, що обгортаються.
{{
let n = 1.23456;
let s = n.toFixed(2);  // Number(n).toFixed(2);
console.log(s);        // 1.23
}}

@3 {Зауваження}.
Виклик конструктора Number(1) не  теж саме, що виклик new Number(1).
{{
> typeof 1
'number'
> typeof Number(1)
'number'
> typeof new Number(1)
'object'
}} 
Виклики на зразок Number(1) послуговують для явного перетворення типу
Виклик new Number(1) не має розумного застосування.

@2 Задачі

@6 Правильне віднімання | 937

@6 Розбір речовинних чисел | 938