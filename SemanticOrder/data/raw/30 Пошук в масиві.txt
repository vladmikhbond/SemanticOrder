@1 30 Пошук в масиві

@3 {Задача пошуку}
Є масив xs і деяке значення k. Знайти індекс елемента k в масиві xs.
Якщо такого елемента в масиві немає, повернути -1.

@2 Послідовний пошук

@3 Послідовний пошук полягає в тому, щоб послідовно переглядати елемент за елементом,
поки не потрапимо на k або не досягнемо кінця масиву.
{{
function serialSearch(xs, k)
{
   for (let i = 0; i < xs.length; i++)
      if (xs[i] == k)
         return i;
   return -1;
}
}}

@3 Алгоритм складається з трьох частин: 1 - підготовчої, 2 - циклічної і 3 - заключної.
{{
t = t1 + n * t2 + t3, де n - число повторень циклу
}}

@3 Швидкодія алгоритму залежить тільки від складу циклічної частини.
{{
t = n * 3 * c, де c - середній час виконання операції
}}

@3 {Питання:} чи можна поліпшити послідовний пошук так, щоб він виконував менше трьох операцій за одне обертання циклу?

@2 Двійковий пошук

@3 Якщо масив впорядкований, можна застосувати не послідовний, а двійковий пошук.

Приклад - [[Ord_array.png]]

@3 {Алгоритм}
1. Ділимо область пошуку навпіл і порівнюємо шуканий ключ k з елементом в середині області - m.
2. Якщо k = m, пошук завершено, повертаємо індекс елемента m.
3. Якщо k < m, продовжуємо пошук в лівій половині.
4. Якщо k > m, продовжуємо пошук в правій половині.

Якщо область пошуку порожня, повертаємо -1 в знак того, що шуканого ключа в масиві немає.

@3 Будемо визначати область пошуку так, як це робить метод slice, тобто,
із включенням лівої і виключенням правої границі.
Якщо a - початок області, b - кінець області, то [a, b) - область пошуку,
{{
function binSearch (xs, k, a, b) {
   if (b - a <= 0)  
      return -1;
   let i = (a + b) / 2 | 0;
   if (xs[i] == k) 
      return i;
   if (xs[i] > k) 
      return binSearch(xs, k, a, i);
   return binSearch(xs, k, i + 1, b);
}
}}

@3 Визивати таку функцію доведеться з 4 параметрами, а не з 2, як того очікує користувач.
{{
let arr = [2,4,5,6,8,9];
console.log(binSearch(arr, 5, 0, arr.length) )
}}

@3 Виправити положення можна за допомогою функції-обгортки.
{{
function binSearch(xs, k) {
   return bs(xs, k, 0, xs.length);

   function bs (a, b) {
      if (b - a <= 0)  
         return -1;
      let i = (a + b) / 2 | 0;
      if (xs[i] == k) 
         return i;
      if (xs[i] > k) 
         return bs( a, i);
      return bs(i + 1, b);
   }   
}
}}


@3 Двійковий пошук швидше послідовного, він не вимагає відвідування всіх елементів масиву.
{Питання}. Скільки елементів у гіршому випадку відвідує двійковий пошук?

@2 Підсумки

@3 Швидкість послідовного пошуку залежить тільки від складу його циклічної частини.
@3 Двійковий пошук набагато швидше послідовного, але вимагає порядку.

@2 Задачі

@6 Двійковий Пошук в Масиві | 530
@6 Злиття Упорядкованих Масивів | 575