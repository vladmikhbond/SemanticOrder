@1 10 Тип Symbol
@@ Symbol

@3 Символи – відносно новий примітивний тип даних.
{{
let sym = Symbol();
console.log(typeof sym); // symbol
}}

@3 Призначення символів – бути унікальними ідентифікаторами. Функція Symbol() завжди повертає унікальне значення.
{{
let s1 = Symbol();
let s2 = Symbol();
console.log (s1 === s2) // false
}}

@3 У функцію Symbol можна передати параметр - дружнє ім'я символу (далі просто ім'я).
Ім'я з'явиться у рядковому поданні символу і це можна використовувати під час налагодження.
Дружнє ім'я не є унікальним.
{{
let s = Symbol('abc');
console.log(s) // Symbol(abc);
}}

@3 Тип Symbol знадобився для ключів властивостей. 
Він виключає колізію ключів з різних бібліотек.
{{
let sym = Symbol('name')
let obj = {[sym]: 'foo'}

console.log(obj[sym])
}}

@3 На відміну від інших простих типів, символи не перетворюються автоматично на рядки.
{{
alert(Symbol("id")) // _помилка_
}}



@2 Well known symbols
@@ сховищ+ символ+|Symbol.for|Symbol.keyFor|Symbol.iterator

@3 Існує реєстр (глобальне сховище) символів, з якого можна витягувати символ на ім'я.
Функція Symbol.for повертає символ із даним ім'ям, але якщо такого у реєстрі немає, створює символ і заносить до реєстру.
{{
// Створення символу в реєстрі
> let vasia = Symbol.for("Vasia")

// символ вже є, читання з реєстру
> Symbol.for("Vasia") === vasia
true
}}

@3 Зворотне завдання - дізнатися про ім'я символу, вирішує функція Symbol.keyFor.
{{
> Symbol.keyFor(Symbol.for("Vasia"))
}}

@3 Деякі символи з глобального сховища служать для назви системних якостей.
Вони не мають імен, але на них посилаються константні властивості функції Symbol, наприклад, Symbol.iterator.
{{
var it = [10, 20, 30][Symbol.iterator]()
console.log(it.next())
console.log(it.next())
console.log(it.next())
}}