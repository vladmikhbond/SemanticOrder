@1 13 Функції 2 (функціональний об'єкт)

@2 Функціональний об'єкт
@@ функціональн+ об'єкт+

@3 В результаті виконання команди function компілятор створює об'єкт типу function і надає йому ім'я.
{{
function foo() {
   alert("Hi")
}
}}

@3 Функціональний об'єкт  створюється як результат обчислення функціонального виразу.
Йому можна надати ім'я.
{{
let foo = function() {
   alert("Hi")
}
}}

@3 Або не надавати, а передати функції як аргумент.
{{
alert(function() {
   alert("Hi")
})
}}

@3 Або викликати негайно.
{{
(function() {
   alert("Hi")
})()
}}

@3 Ім'я функції прийнято будувати за шаблоном "дієслово-іменник", наприклад, "getFile", "showAnswer".


@2 Конструктор Function
@@ Function

@3 Як і будь-який об'єкт, функція може бути створена конструктором.
Конструктор отримує два рядки: у першому рядку параметри, у другому - тіло функції.
{{
let sum = new Function('a,b', 'return a+b; ');
alert( sum(1, 2));
}}

@3 {Примітка}. Виклику конструктора Function потрібно надавати перевагу перед викликом небезпечної функції eval().


@2 Властивості функціонального об'єкта
@@ Function

@3 Функція має властивість arguments - псевдомасив аргументів функції.

@3 Знаючи це, визначення функції avg легко узагальнити на будь-яку кількість аргументів.
{{
function avg() {
    let sum = 0;
    for( v of avg.arguments)
       sum += v;
    return sum / avg.arguments.length;
}
}}

@3 У сучасному JS те саме краще робити за допомогою оператора spread (...).
{{
function avg(...args) {
    let sum = 0;
    for(v of args)
       sum += v;
    return sum / args.length;
}
}}

@3 args – справжній масив, з методами map, forEach та інших., на відміну властивості функції arguments.
Оператор spred може стояти лише перед останнім параметром.

@3 Властивість name зберігає ім'я функції у вигляді рядка.
{{
function Petia() {}
console.log(Petia.name);

let John = function(x) { return x; }
console.log(John.name);
}}

@2 Методи функціонального об'єкта
@@ call|apply

@3 Функціональний об'єкт має метод call().
За допомогою виклику f.call() можна встановити бажане значення контексту this.
Наприклад, ми хочемо, щоб у тілі функції this посилався на рядок "Hi!".
{{
avg.call("Hi", 1,2,3)
}}

@3 Метод apply відрізняється від call тим, що усі аргументи, крім першого, передаються йому зібрані в масив.
{{
avg.apply("Hi", [1,2,3])
}}

@3 Приклад. Знайти максимум у масиві.
{{
let arr = [2,3,1]
alert(Math.max.apply(null, arr))
}}

Але у сучасному JS це краще робити за допомогою оператора spread.
{{
alert(Math.max(...arr))
}}

@6 Сума П'яти Чисел | 502
