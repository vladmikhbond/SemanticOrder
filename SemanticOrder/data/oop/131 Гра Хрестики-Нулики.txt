@1 131 Гра Хрестики-Нулики

@2 Умови гри
@@ -

@3 Гра іде на полі 10х10. 
Гравці ходять по черзі. 
Виграє той, хто першим поставить 5 своїх позначок підряд по вертикалі, горизонталі або діагоналі.
Першими ходять хрестики.

@3 {Основний сценарій}
   
На екрані відображується поточне поле гри.
Перший гравець робить хід.
Програма перевіряє коректність - хід коректний.
Програма перевіряє стан гри - гра не закінчена.

Відображується поточне поле гри.
Другий гравець робить хід.
Програма перевіряє коректність - хід коректний.
Програма перевіряє стан гри - гра не закінчена.

@3 {Додаткові сценарії}

Програма перевіряє коректність - хід не коректний.
Програма просить зробити інший хід.

Програма перевіряє стан гри - гра закінчена.
Основний цикл переривається.
Програма сповіщає про результат.

@3 Реалізуємо гру в архітектурі консольного застосування на платформі .NET 6.

@2 Модель
@@ модел+

@3 Програма складається з класів. Кожен клас програми має відповідати за щось одне.
Класи моделі відповідають за логіку гри, незалежно від того, 
як саме бачать гру гравці і як саме вони роблять свої ходи.

@3 Моделлю гри буде квадратне поле, яке складається з окремих комірок.
Комірка може зберігати хрестик, або нулик, або бути вільною. 
Стан комірки буде відображувати окремий тип - enum 
{{
public enum CellState { Empty, Cross, Zero};
}}

@3 {Перелічуваний тип даних} - тип даних що складається з множини іменованих значень.
В мові C# ці значення - цілі числа.
Переваги переліків в додатковому контролю типів та виразності програмного коду.

@3 Модель гри буде втілювати клас Field.
{{
public class Field
{
   public int Size { private set; get;}

   CellState[] cells;

   public Field(int size)
   {
      Size = size;
      cells = new CellState[Size * Size];
      Array.Fill(cells, CellState.Empty);
   }

   public CellState this[int r, int c]
   {
      set { cells[r * Size + c] = value; }
      get { return cells[r * Size + c]; }
   }
}
}}

@3 В програмі поле можна було б представити двомірним масивом, 
але набагато зручніше мати справу зі звичайним масивом,
Тому скористаємося одномірним масивом, але приховаємо його за індексатором.


@2 Вигляд (вид, уявлення)
@@ вигляд+

@3 За відображення буде відповідати клас View.
Вигляд відображує модель, тому залежить від неї.
Залежності треба вводити через конструктор, так їх легше відстежувати
і навіть автоматизувати таке відстежування
{{
public class View
{
   Field field;

   public View(Field field)
   {
      this.field = field;
   }

   public void Show()
   {
      Console.Clear();
      for (int r = 0; r < field.Size; r++)
      {
         for (int c = 0; c < field.Size; c++)
         {
            if (field[r, c] == CellState.Cross)
               Console.Write(" X");
            else if (field[r, c] == CellState.Zero)
               Console.Write(" O");
            else
               Console.Write(" .");      
         }
         Console.WriteLine();
      }

   }
}
}}

@2 Головна програма

@3 Головна програма буде відповідати за взаємодію з користувачем.
{{
Field field = new Field(5);
View view = new View(field);

string turn;
while (true)
{
   view.Show();
   Console.Write("Cross turn > ");
   turn = Console.ReadLine();
   field.Turn(turn, CellState.Cross);

   view.Show();
   Console.Write("Zero turn > ");
   turn = Console.ReadLine();
   field.Turn(turn, CellState.Zero);
}
}}

@3 Основу програми становить нескінченний цикл,
в якому дії користувача трансформуються у виклики методів моделі та вигляду.

@3 Метод field.Turn повинен змінювати стан моделі, додаючи хрестик
або нулик на ігрове поле. Також він повинен перевіряти коректність ходу і сповіщати про 
завершення гри, якщо воно відбулося.
Стан гри закодуємо так
{{
   public enum GameState { Continue, CrossWon, ZeroWon, Draw, BadTurn };
}}

@3 Метод Turn зараз програмувати не будемо, а замінимо заглушкою.
{{
public GameState Turn(string turn, CellState mark)
{
   this[0, 0] = mark;
   return GameState.Continue;
}
}}

@2 Шаблон MVC
@@ MVC

@3 Розподілення відповідальності між класам, яке ми впровадили, не випадкове,
воно відповідає архітектурному шаблону модель–вигляд–контролер,
запропонованому ще в 70-х роках минулого сторіччя.
[[https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller]]

