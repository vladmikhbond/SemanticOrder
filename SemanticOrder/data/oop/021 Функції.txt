@1 021 Функції

@2 Статичні методі
@@ void

@3 Вільних функцій в C# немає. Найбільш близькі до них статичні методи.
Статичні методи - це функції, оголошені в класі.
{{
class C {
    static int Summa(int x, int y)
    {
         return x + y;
    }
}
}

@3 Якщо повертати значення з функції не потрібно, пишемо void.
{{
static void Print(int x)
{
   Console.WriteLine(x);
}
}}

@3 void це не тип, а позначка, що функція не повертає ніякого значення.

@2 Параметри за замовчанням
@@ -

@3 Кількість аргументів у визові функції повинна співпадати із кількістю параметрів.

@3 Але параметри методів можуть мати значення за замовчанням.
Таким параметрам аргументів можна не надавати.
{{
Console.WriteLine(Summa());    // 5

static int Summa(int x=2, int y=3)
{
   return x + y;
}
}}

@2 Специфікатор ref
@@ ref|out

@3 Аргументи {завжди} передаються параметрам за допомогою копіювання, але
для посилальних типів копіюється посилання,
для значних типів копіюється значення.

@3 Специфікатор ref означає, що аргумент буде укладено всередину безіменного об'єкта і
під час передачі буде скопійовано не сам аргумент, а посилання цей об'єкт.

@3 Значущий тип із ref передається як посилальний.
Такий метод Swap очікувано не працює.
{{
static void Swap(int a, int b)
{
    var t = a; a = b; b = t;
}
}}

@3 Метод Swap працюватиме, якщо помітити його параметри як посилання.
{{
int x = 3, y = 5;
Swap(ref x, ref y);
Console.WriteLine(x + "  " + y);

static void Swap(ref int a, ref int b)
{
   var t = a; a = b; b = t;
}
}}

@3 Для посилальних типів специфікатор ref також має сенс.
З його допомогою всередині методу можна змінити як значення масиву, а й посилання нею.
{{
static void Split(int s, ref int[] arr)
{
    arr = s.Split('');
}
}}

@3 Втім, в останньому прикладі природніше застосувати не ref, а інший специфікатор - out.
Відміна out в тому, що він не вимагає попередньої ініціалізації аргументу.
 
@2 Змінна кількість параметрів
@@ params

@3 Якщо параметр-масив позначити як params,
то передавати значення такому параметру можна і через масив, і через окремі елементи.

@3 Наприклад, один із методів Console.WriteLine має змінну кількість аргументів.
{{
Console.WriteLine("{0} {1} {2} ", 10, 20, 30);
}}

@2 Завдання

@6 Знакопеременная Сумма  | 121
@6 Сложить Нечетные Числа  | 122
@6 Число Разрядов  | 123
@6 Факториал  | 125
@6 Ряд Синуса  | 127
@6 Сумма Дробей  | 128
@6 Цепная Дробь  | 129
@6 Сумма Уникальных Дробей  | 130


