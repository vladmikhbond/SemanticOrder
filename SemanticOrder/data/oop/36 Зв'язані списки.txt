@1 36 Зв'язані списки
@@ зв'язан+|голова;голови;голову|хвіст;хвоста|LinkedList

@3 В основу колекції може бути покладений не масив, а зв'язаний список.
Кожен елемент списку зберігає в собі якесь корисне значення і посилання на наступний елемент.
[[List1.png]]

@3 Зв'язаний список поважна структура даних і в деяких мовах програмування він навіть послуговує замість масиву.

@3 В стандартній бібліотеці .NET існує клас LinkedList, але ми визначимо власний тип списку.
Дивлячись на рисунок, можна припустити, що нам знадобляться два типи
- елемент списку з двома полями,
- колекція таких елементів.

@3 Але ми будемо виходити з рекурсивного визначення списку, яке притаманна функціональному програмуванню.
Список - це пустий список або пара, яка складається зі значення і посилання на інший список.
Перший елемент пари традиційно зветься головою списку, а другий - хвостом списку.
Роль пустого списку виконує константа null.
{{
class LinkList<T>
{
   // голова
   public T Head;
   // хвіст
   public LinkList<T> Tail;

   // конструктор
   public LinkList(T head, LinkList<T> tail = null) {
      Head = head;
      Tail = tail;
   }
}
}}

@3 Щоб бачити результати подальших операцій зі списком, перевизначимо метод ToString().
{{
public override string ToString()
{
   if (Tail == null)
      return Head.ToString();
   return $"{Tail}, {Head}";
}
}}

@3 Метод Add додає до списку ще один елемент.
{{
public void Add(T value)
{
   var t = new LinkList<T>(Head, Tail);
   Head = value;
   Tail = t;
}
}}
[[List2.png]]

@3 Метод Remove() - видаляє голову списку.
{{
public void Remove()
{
   if (Tail != null)
   {
      Head = Tail.Head;
      Tail = Tail.Tail;
   }
}
}}

@3 Метод Find повертає посилання на елемент val,
тобто виконує пошук.
{{
public LinkList<T> Find(T val)
{
   if (Head.Equals(val))
      return this;
   return Tail;
}
}}

@3 Індексатор (який працює повільно).
{{
public T this[int i]
{
   get => i < 0  ? throw new IndexOutOfRangeException() : 
          i == 0 ? Head : this[i - 1];
}
}}

@2 Часова складність операцій
@@ -

@3 Кожна зі структур має свої переваги і свої недоліки.
{{
//                    Масив  Список
Додавання елементу    O(1)   O(1)
Пошук за індексом     O(1)   O(n)
Вставка               O(n)   O(1)
Видалення             O(n)   O(1)
Пошук за значенням    O(n)   O(n)
}}

@2 Інші різновиди списків
@@ двонаправлен+

@3  З вказівником на останній елемент
Циклічний
Двонаправлений
[[List3.png]]

@3 Бібліотечна колекція LinkedList<T> заснована саме на двонаправленому списку.
Зауважимо, що колекція LinkedList не реалізує інтерфейс IList<T>.


@2 Завдання

@6 Циклічна Послідовність | 311
@6 Циклічну Послідовність у Рядку | 312