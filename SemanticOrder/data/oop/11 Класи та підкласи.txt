@1 11 Класи та підкласи

@2 Підкласи
@@ підклас+

@3 Спадкування також називають субкласування.
Вирази "бути підкласом" та "бути спадкоємцем" - синоніми.

@3 Питання: Що доцільно зробити класом, а що підкласом
 - Point чи ColoredPoint?
 - Rectangle чи Square?

@3 Щоб дати обґрунтовану відповідь на друге питання,
реалізуйте властивості: W – ширина, H – висота, S – площа, P – периметр.
@@ {{
class Rectangle {
    public virtual int H { get; set; }
    public int W { get; set; }
    public int S
    {
        get { return W * H; }
    }
    public int P
    {
        get { return (W + H) * 4; }
    }
}

class Square: Rectangle
{
    public override int H
    {
        get { return W; }
        set { W = value; }
    }
}
}}


@2 Спадкування та перетворення типу
@@ перетворенн+;приведен+|явн+ приведенн+|неявн+ приведенн+

@3 Хоча посилання - лише адреса пам'яті, в статично типізованих мовах воно має тип.
Змінна посилального типу T може посилатися лише на екземпляри типу T або нащадків T.
{{
Point p = new Point();
Point сp = new СoloredPoint();
}}

@3 Це випливає з того, що будь-яка кольорова точка є в той же час і просто точкою.

@3 Виконуючи присвоювання, компілятор неявно привів тип ColoredPoint до Point.
{{
Point сp = (Point) new ColoredPoint();
}}

@3 Компілятор змінив тип самостійно, тому що це безпечно -
все, що має Point, є і в його спадкоємця, ColoredPoint.

@3 Можливе і протилежне приведення
{{
    ColoredPoint p = (ColoredPoint) New Point ();
}}
Але це небезпечне приведення, тому програміст повинен робити його явно.   

@3 У жодному разі не можна приводити типи, які не перебувають у відношенні спадкування, наприклад, Rect і Point.

@2 Параметри методів
@@ -

@3 Неявне перетворення типу відбувається і під час виклику методів.
Параметр типу Point може прийняти аргумент ColoredPoint. Зворотне заборонено. 

@3 Щоб надати методу більшої універсальності, потрібно обирати найбільш загальні типи параметрів.

@3 З типом значення, що повертається ситуація прямо протилежна -
чим більш загальний тип повертає метод, тим менший діапазон його застосування.

@2 Приведення значущих типів
@@ Convert|статичн+ клас+

@3 Неявні приведення значущих типів також можливі. 
В цілому вони дозволені, коли нема ризику втрати інформації,
наприклад, ціле число можна привести до довгого цілого, а навпаки - зась.
{{
long n = 333;  // OK 
int n = 0L;    // ERROR
}}

@3 На відміну від перетворення посилань приведення структур досягається 
створенням нової структури у пам'яті.

@3 Методи перетворення вбудованих типів сконцентровані у статичному класі Convert.

@3 Статичними називають класи, у яких всі всі члени статичні.

