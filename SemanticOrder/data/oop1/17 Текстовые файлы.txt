@1 17 Текстовые файлы

@3 Порядок работы с файлами: 
1. Открыть файл (захватить ресурс ОС).
2. Читать или писать в него.
3. Закрыть файл (вернуть ресурс).

@3 Файл можно рассматривать как поток байтов. 
Это делает класс {FileStream}, определенный   в  пространстве {System.IO}.

@3 Файл можно рассматривать как поток символов.
Это делают два абстрактных класса:
[[text_file_classes.png]]

@3 Методы класса TextWriter: 
{{
public virtual void Write(тип value);   // закрывает записываемый файл и освобождает все ресурсы
public virtual void WriteLine(тип value);   // записывает в файл данные  только после записи 
           добавляет в файл символ окончания строки
public virtual void Write (string format,  params Object[] arg);   //  записывает в файл данные
public virtual void Flush();   // записывает в файл оставшиеся в буфере данные и очищает буфер
public virtual void Close();   // закрывает записываемый файл и освобождает все ресурсы
}}

@3  Есть асинхронные   версии методов   записи  и  чтения  из файлов.

@3 Пример записи. Дан массив строк, сохранить его в текстовом файле.  
{{
 string[] ss = { "1111", "222 222", "33333" };

 TextWriter writer = new StreamWriter("F:\\Temp\\111.txt");
 foreach (string s in ss)
 {
     writer.WriteLine(s);
 }
 writer.Close();    
}}

@3 Методы класса TextReader: 
{{
public virtual string ReadLine();   //  считывает одну строку в файле
public virtual string ReadToEnd();   //  считывает весь текст из файла
public virtual int Read(ref char[] buffer, int index, int count);   //  Считывает  данные.  
                                               buffer  - массив, куда считываются символы, 
                                              index - индекс в массиве, начиная с которого записываются считываемые символы, 
                                                count - максимальное количество считываемых символов
public virtual int Read();   //   считывает и возвращает следующий символ в численном представлении. 
public virtual int Peek();     // возвращает следующий доступный символ, 
                                        если символов больше нет, то возвращает -1
public virtual void Close();    //  закрывает считываемый файл и освобождает все ресурсы
}}

@3 Пример чтения. Задан файл, построчно вывести его на экран.  
{{
TextReader reader = new StreamReader("F:\\Temp\\OOP\\111.txt");
string line;
while ((line = reader.ReadLine()) != null)
{
    Console.WriteLine(line);
}
reader.Close();
}}



@3 В данных примерах файл может и не закрыться, т.е. ресурс могут и не вернуть.

@5 Класс ArrayReader | Разработайте класс ArrayReader, который наследует класс TextReader и позволяет читать текст из массива символов подобно тому, как экземпляр класса StringReader позволяет читать текст из строки. 
{{
class ArrayReader: TextReader
{
    char[] m;
    int current;

    public ArrayReader(char[] array)
    {
        if (array == null)
            throw new ArgumentException();
        m = array;
        current = 0;
    }

    public override int Read()
    {
        if (current >= m.Length)
            return -1;
        return (int)m[current++];
    }
}     
}}

@2 Кодировка символов

@3 В конечном счете в файл попадают не символы, а байты.
Способ перевода символов в байты и обратно определяется кодировкой.

@3 Кодировку осуществляет экземпляр класса Encoder, который передается в объект StreamWriter. 
{{
string[] ss = { "Новая запись", "!!!!!" };
using (TextWriter tw =
        new StreamWriter("F:\\Temp\\OOP\\222.txt", true, Encoding.Unicode))
{
    foreach (string s in ss)
        tw.Write(s + " ");
     tw.WriteLine(" ");
}

}}
@2 Гарантированное освобождение ресурсов

@3 Для гарантированного исполнения некоторого кода его помещают в блок finally, следующий за блоком try.  
{{
try {
     // рискованный код
}
finally
{
     // обязательный код
}  
}}

@3 Пример. 
{{
TextWriter writer = null;
try
{
    writer = new StreamWriter("d:\\111.txt");
    foreach (string s in ss)
        writer.WriteLine(s);
}
finally
{
    writer.Close();
}  
}}

@2 Блок using

@3 Гарантированное высвобождение ресурсов обеспечивает блок using. 
{{
using (TextWriter wr = new StreamWriter("books.txt"))
{
    foreach (string s in ss) {
        writer.WriteLine(s);
   }
}   
}}

@@ @3 Блок using возможен лишь для объектов, реализующих интерфейс IDisposable.








