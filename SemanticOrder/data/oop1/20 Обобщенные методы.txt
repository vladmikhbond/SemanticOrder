@1 20 Обобщенные методы

@@3 Обобщенные типы имеются  и в C++, и в Java, но впервые обобщенные типы появились в 1970-х в языке Клу (Барбара Лисков).

@@3 [[barbara-liskov.png]]
Профессор Массачусетского технологического института (MIT) Барбара Лисков (Barbara Liskov) получила премию Тьюринга за вклад в теорию абстракции данных, которая упрощает создание сложных программ.

@@3 Барбара Лисков сформулировала определение понятия подтипа, известное как принцип подстановки Лисков:
Пусть t.Q является свойством, которым обладает объект t некоторого типа T.  
Если тип S является подтипом T, то объект s, имеющий тип S, также должен обладать свойством s.Q.

@@3 Другими словами, потомок может только расширять возможности предка, но не убавлять и не изменять их.

@@3 Третьими словами, функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа.

@@3 Четвертыми словами, если в программе подменить все объекты объектами производных типов, она должна продолжать правильно работать.

@@3 Принцип подстановки применяют для решения вопроса, кто кого наследует и наследует ли вообще.

@@3 Например, при наследовании Point <- ColoredPoint принцип подстановки выполняется.
Но если в ColoredPoint свойства X и Y переопределить так, чтоб они были только положительными
или только для чтения, принцип подстановки нарушится.

@@2 Обобщенные методы

@3 Чтобы написать обобщенный метод, сначала нужно написать обычный метод.
{{
static int Count(int[] xs, int k)
{
    int c = 0;
    foreach (int x in xs)
        if (x == k)
            c++;
    return c;
}
}}

@3 А потом заменить конкретный тип {универсальным параметром} 
{{
static int Count<T>(T[] xs, T k) { ...}
}}

@2 Вывод типа компилятором

@3 При вызове обобщенного метода, кроме аргументов-данных, ему нужно передавать и аргументы-типы.  

@3 Если тип не передать, компилятор попытается его вывести. 
{{
int n = Count(ss, "a")
}}

@3 Он сделает это, решив систему уравнений: 
{{
     string[] = T[]
     string = T   
}}
относительно неизвестного T.

@@2 Некоторые  особенности
@@3    Сравнения  по  равенству 
@@3    Сравнения   по  <, >


@2 Ограничения параметрического типа

@3 Мы можем написать обобщенный метод, который не сможет выполниться для некоторых типов-аргументов. 
{{
// метод - фабрика
static T[] One <T>()  {
     T[] t = { new T() };
      return t;
}
}}

@3 Этот код не скомпилируется, поскольку он не верен для тех типов, у которых нет конструктора по умолчанию. 
Чтобы код скомпилировался, на параметр T нужно наложить ограничение.

@3 Ограничения на типы-параметры задаются в предложении where. 
{{
 static T[] One <T>() where T: new()  {
     T[] t = { new T() };
      return t;
 }
}}

@3 Всего существует 4 вида ограничений: 
{{
where T: struct,         // T - значимый тип
where T: class,          // T - ссылочный тип
where T: new()           // тип T имеет конструктор по умолчанию
where T: Name1, Name2,…  // тип T наследует класс или интерфейс
}}

@3 Если для универсального параметра задано несколько ограничений, то они должны идти в определенном порядке:

- Название класса, class, struct. Одновременно можно определить только одно из этих ограничений

- Название интерфейса

- new()


@3 Как значения  по   умолчанию   следует  использовать   {default(T)}


@2 Задачи

@6 Обобщенное Несравнение  | 201
@6 Обобщенный Поиск  | 202
@6 Обобщенный Максимум  | 203
@6 Обобщенный Метод Zip  | 222
@6 Обобщенный Метод Agregate  | 223
@6 Обобщенная Композиция | 225 

