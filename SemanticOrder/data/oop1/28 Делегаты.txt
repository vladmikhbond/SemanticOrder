@1 28 Делегаты

@3 В программе нужны ссылки не только на данные, но и на функции.
Это требуется, когда одну функцию передают в другую функцию в качестве аргумента или возвращают в качестве значения.  

@3 Пример. Пусть имеется массив чисел, и к каждому элементу массива необходимо применить функцию sin, 
чтобы получить массив результатов.
{{
static double[] MapSin(double[] arr)
{
    double[] res = new double[arr.Length];
    for (int i = 0; i < arr.Length; i++)
        res[i] = Math.Sin(arr[i]);
    return res;  
}
}}

@3 Вместо sin можно применить функцию cos, abs и т.д.

@3 Объявим функцию Map, которая получает два аргумента: массив и функцию.
{{
static double[] Map(double[] arr, Function f)  
{
    double[] res = new double[arr.Length];
    for (int i = 0; i < arr.Length; i++)
        res[i] = f(arr[i]);
    return res;  
}
}}

@3 Тип функционального параметра f называется  делегатом,
и этот тип должен быть объявлен:  
{{
delegate double Function(double x);   
}}
Объявление делегата очень похоже на заголовок метода. 

@3 Когда вызывают метод Map, ему передают массив и функцию. 
{{
double[] arr = {0.1, 0.2, 0.3};
double[] res = Map(arr, Math.Sin);   
}}

@2 Как устроен делегат

@3 Делегат - это класс.
Из объявления делегата 
{{
delegate double Function(double x);   
}}
компилятор создает объявление класса.  
{{
public sealed class Function: System.MulticastDelegate
{
    public Function(object target);
    public double Invoke(double x);
    // public IAsyncResult BeginInvoke(int x, AsyncCallback cb, object state);
    // public bool EndInvoke(IAsyncResult result);
}
}}

@3 Метод Invoke(), вызывает все целевые методы делегата в порядке регистрации (их может быть более одного).

@3 Если делегат это класс, то ссылка на метод - это экземпляр класса и потому должна создаваться при помощи конструктора.   
{{
double[] res = Map(arr, new Function(Math.Sin));   
}}

@3 Но разрешается писать сокращенно.
{{
double[] xs = Map(arr, Math.Sin); 
}}

@3 Делегаты могут ссылаться на статические методы и на методы экземпляра.

@2 Лямбда-выражения

@3 Лямбда-выражение - это безымянный делегат. Например,
{{
// функция с именем
double Circle(double r) 
{
    return 2 * Math.PI * r;
}

// функция без имени
r => 2 * Math.PI * r
}}

@3 Синтаксис лямбда-выражения:
{(список_параметров) => выражение}

@3  Благодаря лямбда-выражениям, аргументами могут быть не только безымянные данные, но и безымянные функции.
{{
double[] xs = Map(
    new double[] { 0.1, 0.2, 0.3}, 
    r => 2 * Math.PI * r );
}}

@2 Задачи

@6 Выражение для суммирования  | 224
@6 Композиция функций   | 642
@6 Функция Map   | 643
@6 Функция Zip  | 644
@6 Функция Join 	  | 645
@6 Функция Fold 	  | 646

@6 Обобщенный Делегат  | 221


