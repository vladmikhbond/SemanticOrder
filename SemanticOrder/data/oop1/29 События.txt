@1 29 События

@3 Событие, это  ситуация, при возникновении которой  произойдет действие или несколько действий.
Имеется объект - источник событий.
Имеются функции, которые подписаны на этот вид событий (слушатели события).
Когда происходит событие, вызываются все функции, подписанные на это событие.
[[events.png]]

@3 Источник событий имеет список ссылок на слушателей, который первоначально пуст.
Подписка состоит в  том, что в список добавляется ссылка на функцию, "отписка" - в том, что ссылка на функцию удаляется из списка.

@2 События в C#

@3 Поддержка событий в языке С# заключается в том, что есть специальный член класса - event.
Тип event'a - делегат.

@3 С event'ом можно выполнять три операции:
- подписку,
- отписку,
- вызов (только из определения класса).

@2 Пример. 

@5 Создадим обобщенный класс  стека. |
{{
class Stack<T>
    {
        T[] stack;
        int top;
        const int INIT_CAP = 20;

        public Stack(int size)
        {
            stack = new T[size];
            top = 0;
        }

        public Stack() : this(INIT_CAP) { }

        public int Top
        {
            get
            {
                return top;
            }
        }

        public void Push(T a)
        {
            if (top == stack.Length)
            {
                throw new ArgumentException("Stack is Full");
            }
            stack[top++] = a;
        }

        public T Pop()
        {
            if (top == 0)
            {
                throw new ArgumentException("Stack is empty");
            }
            return stack[--top];
        }
       
        public int Length
        {
            get
            {
                return stack.Length;
            }

            set
            {
                if (value < top)
                    throw new ArgumentException("Error size");
                T[] mas = new T[value];
                for (int k = 0; k < top; k++)
                    mas[k] = stack[k];
                stack = mas;
            }
        }
      public override string ToString() 
        {
            string s="";
            for (int i=0; i<top;i++)
                s += stack[i] + " ";
            return s;
        }
    }

}}

@3  Попробуем  отследить динамику  изменений  состояния   стека, создав   событие, которое будет  вызываться   при   успешно  прошедших  операциях: извлечении  элемента,  добавлении элемента, изменении размера стека.

@3 События объявляются в классе с помощью ключевого слова event, после которого указывается тип делегата, который представляет событие.
@3 Добавим в  класс стека :
{{
        public delegate void StackHandler(string message);
        public event StackHandler Good;
}}

@3 Определив событие, мы можем его вызвать в программе как метод, используя имя события:
{{Good("Произошло действие");}}
@3 Но   лучше  так:
{{Good?.Invoke("Произошло действие");}}

@5 Укажем   в  классе Stack, когда   произошло событие:  |
{{

class Stack<T>
    {
        public delegate void StackHandler(string message);
        public event StackHandler Good;
        T[] stack;
        int top;
        const int INIT_CAP = 20;

        public Stack(int size)
        {
            stack = new T[size];
            top = 0;
            Good?.Invoke($"Создан стек на {size} элементов"); 
        }

        public Stack() : this(INIT_CAP) { }

        public int Top
        {
            get
            {
                return top;
            }
        }

        public void Push(T a)
        {
            if (top == stack.Length)
            {
                throw new ArgumentException("Stack is Full");
            }
            stack[top++] = a;
            Good?.Invoke($"В  стек помещено значение {a} ");
        }

        public T Pop()
        {
            if (top == 0)
            {
                throw new ArgumentException("Stack is empty");
            }
            Good?.Invoke($"Из стека  извлечено значение  {stack[--top]} : {this} ");
            return stack[top];
        }
        
        public int Length
        {
            get
            {
                return stack.Length;
            }

            set
            {
                if (value < top)
                    throw new ArgumentException("Error size");
                T[] mas = new T[value];
                for (int k = 0; k < top; k++)
                    mas[k] = stack[k];
                stack = mas;
                Good?.Invoke($"Размер  стека стал  {value} ");
            }
        }

     public override string ToString() 
        {
            string s="";
            for (int i=0; i<top;i++)
                s += stack[i] + " ";
            return s;
        }
    }


}}

@3 В  классе  тестирования   внесем  изменения:
@3 Добавим   метод – обработчик   события. Пусть он просто выводит на   консоль  сообщения   события 
{{private static void ConsoleMessage(string message)
        {
            Console.WriteLine(message);
        }
}}

@3 И  в методе Main событию  назначим обработчик.
{{static void Main(string[] args)
        {
            Stack<string> StS = new Stack<string>(5);
            StS.Good += ConsoleMessage;    
            ............
      }
}}

@3 Можем добавить и  другого  подписчика на  наше   событие. 

@5 Cоздать  класс {FileHandler}, который  будет  отправлять  сообщения  стека  в  файл в методе  {FileMessage}.  |

@3 И добавим   подписку  на  событие в   методе  Main:
{{static void Main(string[] args)
        {
            Stack<string> StS = new Stack<string>(5);
            StS.Good += ConsoleMessage;
            string path = @"F:\Temp\OOP\FileEvent.txt";
            FileHandler F = new FileHandler(path);
            StS.Good += F.FileMessage;
         .............
        }        
}}

@5 Добавьте в  стек другое   событие, которое будет  вызываться  в   случае  неудачных    действий, и  измените соответственно логику  работы   стека. |


@@ @2 Пример2 . Коллекция с событиями

@@ @3 Имеется коллекция, в которую можно добавлять и удалять элементы.
@@ {{
@@ public class MyList<T> : List<T>  {   }
@@ }}

@@ @3 Пусть она издает событие ChangedEvent, когда ее содержимое меняется.
@@ {{
@@ public class MyList<T> : List<T>
@@ {
@@     public event Action ChangedEvent;

@@     public new void Add(T item)
@@     {
@@         base.Add(item);
@@         ChangedEvent?.Invoke();
@@     }

@@     public new void Remove(T item)   {... }
@@ }


@@ @3 Поместим на форму элемент ListBox и привяжем к нему список книг.
@@ {{
@@ MyList<Book> _books = new MyList<Book>();

@@ public Form1()
@@ {
@@     InitializeComponent();
@@     _books.Add(new Book { Title = "111", Author = "222" });
@@     bookBindingSource.DataSource = _books;
@@     _books.ChangedEvent += _books_ClickEvent;
@@ }

@@ }}

@@ @3 В обработчике события ChangedEvent будем обновлять привязку.
@@ {{
@@ private void _books_ClickEvent(Book book)
@@ {
@@     Text = book.Title;
@@     bookBindingSource.ResetBindings(false);
@@ }
@@ }}
@@ }}
@2 Метод OnChange

@3 Обычно событие Xxx возбуждается в специальном методе OnXxx().
{{
public void OnChanged()
{
    ChangedEvent?.Invoke();
}
}}

@@3 Это позволяет выбирать способ обработки события 
между наследованием и делегированием.

@@ @2 Информация о событии

@@ @3 Сделаем так, чтобы в обработчик попадала информация о событии - удаленная или добавленная книга.
@@ Для этого изменим сигнатуру делегата ChangedEvent.
@@ {{
@@ public event Action<T> ChangedEvent;
@@ }}

@@ @2 События в WinForms

@@ @3 В WinForms для событий принят ряд соглашений.
@@ 1. Имена событий заканчиваются на Event (например, MouseDownEvent) 
@@ а имена делегатов на EventHandler  (например, MouseEventHandler) 

@@ @3 2. Обработчик всегда получает два параметра: object sender и EventArgs e
@@ Второй параметр наследует тип EventArgs

@@ @3 3. События возбуждаются в виртуальных методах On...
@@ {{
@@ protected override void OnMouseDown(MouseEventArgs e)
@@ {
@@     // base.OnMouseDown(e);
@@ }

@@ private void Form1_MouseDown(object sender, MouseEventArgs e)
@@ {
@@ }
@@ }}

@@ @2 Отписка

@@ @3 Отписаться от события можно операцией -=
@@ Обработчик - это синглетон.


@2 Задачи


@6 События Создания и Удаления  | 227
@6 Событие Простое Число  | 228
@6 Класс с Событием Bang  | 647


