@1 131 Классы и подклассы

@3 Наследование также называют субклассированием.
Выражения "быть подклассом" и "быть наследником" - синонимы.

@5 ? | Что является подклассом, точки или цветные точки?

@5 ? | Что является подклассом, прямоугольники  или квадраты? 
Реализуйте свойства: W - ширина, H - высота, S - площадь, P - периметр.
@@ {{
class Rect {
    public virtual int H { get; set; }
    public int W { get; set; }
    public int S
    {
        get { return W * H; }
    }
    public int P
    {
        get { return (W + H) * 4; }
    }
}

class Square: Rect
{
    public override int H
    {
        get { return W; }
        set { W = value; }
    }
}
}}


@2 Наследование и преобразование типа

@3 Хотя ссылка - всего лишь адрес, но в статически типизированных языках у нее есть тип. 
Переменная типа T может ссылаться только на экземпляры T и его потомков. 
{{
Point сp = new СoloredPoint(); 
}}

@3 Это следует из того, что всякая цветная точка, является в то же время и просто точкой.

@3 Выполняя присваивание, компилятор неявно привел тип ColoredPoint к Point.   
{{
Point сp = (Point)new ColoredPoint(); 
}}

@3 Компилятор привел тип самостоятельно, т.к. это безопасно - 
все, что есть у Point, есть и у его наследника - ColoredPoint.

@3 Возможно и противоположное приведение 
{{
    ColoredPoint p = (ColoredPoint)new Point(); 
}}   
Но это опасное приведение, поэтому должно быть сделано явно.

@3 Никоим образом нельзя привести типы, которые не находятся в отношении наследования, например, Rect и Point.

@2 Параметры методов

@3 Неявное преобразование возможно и при вызове методов. 
Параметр типа Point может принимать аргумент типа ColoredPoint. Обратное неверно.

@3 Чтобы придать методу наибольшую универсальность, нужно выбирать наиболее общие типы параметров.

@3 С типом возвращаемого значения ситуация прямо противоположная - 
чем более общий тип возвращает метод, тем уже диапазон его применения.

@@2 Приведение значимых типов

@@3 В отличие от преобразования ссылок, приведение структур достигается созданием новой структуры в памяти.




@@3 Методы преобразования встроенных типов сконцентрированы в статическом классе Convert.

@2 Задачи

@6 Широкий Прямоугольник  | 195

