@1 13 Виртуальные методы

@3 Наследование позволяет избегать дублирования кода.
Другое применение наследования - унификация программного интерфейса (полиморфизм).

@2 Виртуальные методы

@3 Пример. Класс ColoredPoint наследует Point и переопределяет его метод Info().
{{
class Point
{
    public int X { set; get; }
    public int Y { set; get; }
    
    public string Info() { 
      return $"Point: x={X}, y={Y}";
    }  
}

class ColoredPoint : Point
{
    public int Color { set; get; }

    public new string Info() { 
        return $"ColoredPoint: x={X}, y={Y}, color={Color}";
    }  
}
}}

@3 Вызов одного из двух методов Info() зависит от объявленного типа объекта.  
{{
Point cp = new ColoredPoint { X = 1, Y = 2, Color = 3 };
Console.WriteLine(cp.Info());
}}

@3 Виртуальными называют такие методы, вызов которых зависит не от объявленного, а от истинного типа объекта.  
{{
 public virtual string Info() ...
}}

@3 Модификатором {virtual} виртуальный   метод помечается  в базовом классе,  а  чтобы переопределить метод в классе-наследнике, этот метод определяется с модификатором {override}.
@3 Добавим в класс Point метод Print() 
и он будет вызывать Info сообразно с истинным типом this.
{{
public void Print()
{
    Console.WriteLine(this.Info());
}
}}

@3 Другой пример - виртуальный метод ToString().
Сначала в классе A сделаем его не виртуальным.
{{
class A
{
    public new string ToString(){
        return "This is an instance of A";
    } 
}
//////////////////////
A a = new A();
Console.WriteLine(a);
}}

@3 Теперь сделаем его виртуальным и увидим разницу.


@2 Как реализуется виртуальность

@3 {Связывание} – в вызове метода его имя заменяется адресом метода.

@3 {Раннее связывание} – замена происходит во время компиляции.

@3 {Позднее связывание} – замена происходит во время выполнения.

@3 Обычные методы подвергаются раннему связыванию. 
Виртуальные методы подвергаются позднему связыванию. 
Поэтому вызов обычных методов происходит быстрее.

