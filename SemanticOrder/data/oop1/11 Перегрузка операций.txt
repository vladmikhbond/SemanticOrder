@1 11 Перегрузка операций

@3 {{
int a=5,b=4, c=a+b;
int d=a-b;
}}

@3{{
 Vector A = new Vector(3, 5);
 Vector B = new Vector(1, 3);
 Vector C=A+B; ///   ????

}}
@3 Операции - это функции.   {{
a = b + c;
a = operator+ (b, c); }}

@3 {{y = x++;
y = operator++ (x);   }}

@3 Операции перегружаются только для пользовательских типов.
При перегрузке не меняется приоритет, ассоциативность и арность операции.

@3 Операции перегружаются статическими методами того класса, который участвует в операции.
Обычно операции перегружаются для классов данных: точка, фигура, вектор, текст ...

@2 Что можно перегружать

@3 Унарные операции:
+,  -,  !,  ~, ++, —, true, false

@3 Бинарные операции:
+, -, *, /, %, &, |, ^, <<, >>

@3 Операции сравнения:
==, !=, <, >, <=, >=
Операторы сравнения должны перегружаться парами. То есть при перегрузке оператора из пары другой оператор тоже должен перегружаться. 

@2 Что нельзя перегружать

@3 []     ()

@3 Составные присваивания
+=, -=, *=, /=, %=, &=, |=, ^=, <<=, >>=
Составные операторы присваивания не могут быть перегружены явным образом. Перегружаются  неявно при перегрузке бинарной  операции

@3 Условные логические операции
&&, ||
Перегружаются  неявно при ряде   условий
[[https://docs.microsoft.com/ru-ru/dotnet/csharp/language-reference/language-specification/expressions#user-defined-conditional-logical-operators]]

@2 Пример: класс Vector
@3 Вектор на плоскости – два числа, X и Y.   {{
class Vector
{
    public float X {set; get; }
    public float Y {set; get; }

    public Vector(float x, float y)
    {
        X = x; Y = y;
    }
}      }}
@3 Операции над векторами:
- умножение слева на число
- сложение векторов
- вычитание векторов
- унарный минус
- модуль вектора
- скалярное произведение
- инкремент
- декремент
- поворот на угол альфа
... 

@3 Сложение векторов,   v = v1 + v2; 
@3 {{public static Vector operator + (Vector v1, Vector v2)
{
    return new Vector(v1.X + v2.X, v1.Y + v2.Y);
}   }}

@3 Скалярное произведение векторов, s = v1 * v2    
@3 {{public static float operator * (Vector v1, Vector v2)
{
    return v1.X * v2.X + v1.Y * v2.Y;
}   }}

@3 Умножение справа на число,   v =  v1 * k 
@3 {{public static Vector operator *(Vector v, float k)
        {
            return new Vector(v.X * k, v.Y * k);
        }
}}
@3 Модуль вектора, s = ! v  
@3 {{public static float operator ! (Vector v)
{
    return (float)Math.Sqrt(v.X * v.X + v.Y * v.Y); 
}    }}

@3 Унарный минус, v = -v1   
@3 {{public static Vector operator -(Vector v)
{
    return new Vector(-v.X, -v.Y);
}     }}

@3 Перегрузка операций отношения    v1 < v2,  v1 > v2
@3 {{

 // Сравнение на меньше (тот, что ближе к началу координат)
    public static bool operator <(Vector v1, Vector v2)
    {
        return !v1<!v2;
    }
 // Сравнение на больше (тот, что дальше от начала координат)
    public static bool operator >(Vector v1, Vector v2)
    {
        return !v1>!v2;
    }
}}
@3 Операции отношений определяются только парами и обычно возвраща­ют логическое значение. Чаще всего переопределяются операции сравнения на равенство и неравенство для того, чтобы обеспечить сравнение значения некоторых полей объектов, а не ссылок на объект. 


@3 Сравнение, v1 == v2,  v1 != v2   
@3 {{public static bool operator ==(Vector v1, Vector v2)
{
    return object.Equals(v1, v2);
}

public static bool operator !=(Vector v1, Vector v2)
{
    return !object.Equals(v1, v2);
}  }}
@3 Если перегружаются операторы == и !=, то для это­го обычно требуется также переопределить методы Object.Equals() и Object.GetHashCode()

@3 Инкремент,  v = v1++;  v = ++v1;
@3 {{public static Vector operator++(Vector v)
{
    return new Vector(v.X + 1, v.Y + 1);
}  }}
Компилятор сам обеспечивает правильное выполнение операций пре- и постинкремента.

@@ @3 Поворот на угол {а}   v = v1 >> a;

@@ @3 {{x' = x * cos(a) - y * sin(a) 
@@ y' = x * sin(a) + y * cos(a) }}

@3 Перегрузка операторов true и false

@3{{
public static bool operator true(Vector v)
    {
        return v.X != 0 || v.Y != 0;
    }

    public static bool operator false(Vector v)
    {
        return v.X == 0 && v.Y == 0;
    }
}}
@3 После такой перегрузки объект Vector можно использовать в условиях if, while и т.п.


@2 Операции преобразования типа 

@3 Преобразование типа может быть явным или неявным.
@@Преобразование типа может приводить или не приводить к созданию нового значения.   
@@ {{ 
@@ double d  = 123;
@@ int i = (int)12.3;
@@ Control c = textBox1;
@@ }}

@3 Операцию преобразования типа можно перегрузить таким образом 
{{
public static [explicit|implicit] operator ЦелевойТип (ИсходныйТип p) {...}       }}

@3 Для одних и тех же исходных и целевых типов данных нельзя указывать оператор преобразования одновременно в явной и неявной форме


@3 Явное преобразование к float   {{
public static explicit operator float (Vector v)
{
    return !v; 
}    }}

@3 Неявное преобразование к bool  {{
public static implicit operator bool(Vector v)
        {
            return !(v.X == 0 && v.Y == 0);
        }
}}

@3 Неявное  преобразование к String
   {{     public static implicit operator string(Vector v)
        {
            return v.X + " " + v.Y;
        }
}}

@5 Класс Complex |  Объявить класс Complex - комплексное число и перегрузить для него арифметические операции.

@@5 Класс Cout |  Объявить класс Cout и перегрузить для него операцию << , позволяющую выводить на консоль значения выражений.
@@Например,
@@Cout cout = new Cout();
@@cout << 2 + 3;

@5 Класс Set | Объявить класс Set – множество на базе строки символов. Перегрузить для него операции объединения (+), пересечения (*), разности (/) множеств, предиката вхождения множеств (<=), принадлежности элемента множеству ( c % S). Перегрузить преобразование множества в строку и обратно.