@1 12 Наследование
@@ наследован+|потомок;потомк+|предк+;предок

@3 Наследование позволяет создать новый класс не с нуля, а на базе уже существующего класса.

@3 Наследник имеет все поля, методы и свойства, которые есть у предка, но может добавить к ним собственные. 
[[Derivation2.png]]

@3 В памяти, занимаемой объектом, поля потомка следуют за полями предка.

@2 Наследование и конструкторы

@3 Класс Point с конструктором. 
{{
class Point
{
    public int X { set; get; }
    public int Y { set; get; }

    public Point(int x, int y) {
        X = x;
        Y = y;
    }
}
}}

@3 Конструктор наследника явно или неявно вызывает конструктор предка для инициализации унаследованных полей. 
Для явного вызова конструктора предка имеется особый синтаксис.
{{
class ColoredPoint : Point
{
    public int Color { set; get; }

    public ColoredPoint(int x, int y, int color ) : base(x, y)  
    {
        Color = color;
    }
}     
}}

@2 Переопределение полей и методов
@@ переопределен+

@3 Переопределение полей возможно, но бесполезно, т. к. поля наследника будут скрывать одноименные поля предка. 

@3 Добавим в класс Point метод Info(), который возвращает информацию об объекте в виде строки. 
{{
class Point
{
   public int X {set; get;}
   public int Y {set; get;}

   public string Info() { 
      return $"Point: x={X}, y={Y}";
    }  
}
}}

@3 Переопределим этот метод в классе ColoredPoint.
{{
   public string Info() { 
      return $"ColoredPoint: x={X}, y={Y}, color={Color}";
   }  
}}

@2 Уровни доступа
@@ protected

@3 Наследование требует еще одного уровня доступа - protected.
{{
public > protected > private
}}

@3 Возможны комбинации: 
protected [or] internal, 
private [or] protected.

@@3 Если "a" имеет уровень L, то кто его увидит?
[[axxess_levels.png]]

@4 Если класс объявлен с модификатором sealed, то от этого 
класса нельзя наследовать и создавать производные классы. 

@2  Классы и подклассы

@3 Наследование также называют субклассированием.
Выражения "быть подклассом" и "быть наследником" - синонимы.

@5 ? | Что является подклассом, точки или цветные точки?

@5 ? | Что является подклассом, прямоугольники  или квадраты? 
Реализуйте свойства: W - ширина, H - высота, S - площадь, P - периметр.
@@ {{
class Rect {
    public virtual int H { get; set; }
    public int W { get; set; }
    public int S
    {
        get { return W * H; }
    }
    public int P
    {
        get { return (W + H) * 4; }
    }
}

class Square: Rect
{
    public override int H
    {
        get { return W; }
        set { W = value; }
    }
}
}}


@2 Наследование и преобразование типа

@3 Хотя ссылка - всего лишь адрес, но в статически типизированных языках у нее есть тип. 
Переменная типа T может ссылаться только на экземпляры T и его потомков. 
{{
Point сp = new СoloredPoint(); 
}}

@3 Это следует из того, что всякая цветная точка, является в то же время и просто точкой.

@3 Выполняя присваивание, компилятор неявно привел тип ColoredPoint к Point.   
{{
Point сp = (Point)new ColoredPoint(); 
}}

@3 Компилятор привел тип самостоятельно, т.к. это безопасно - 
все, что есть у Point, есть и у его наследника - ColoredPoint.

@3 Возможно и противоположное приведение 
{{
    ColoredPoint p = (ColoredPoint)new Point(); 
}}   
Но это опасное приведение, поэтому должно быть сделано явно.

@3 Никоим образом нельзя привести типы, которые не находятся в отношении наследования, например, Rect и Point.

@2 Параметры методов

@3 Неявное преобразование возможно и при вызове методов. 
Параметр типа Point может принимать аргумент типа ColoredPoint. Обратное неверно.

@3 Чтобы придать методу наибольшую универсальность, нужно выбирать наиболее общие типы параметров.

@3 С типом возвращаемого значения ситуация прямо противоположная - 
чем более общий тип возвращает метод, тем уже диапазон его применения.

@@2 Приведение значимых типов

@@3 В отличие от преобразования ссылок, приведение структур достигается созданием новой структуры в памяти.

@@3 Методы преобразования встроенных типов сконцентрированы в статическом классе Convert.


@2 Задачи

@6 Polygon и Его Потомки  | 191
@6 Наследование Прямоугольника  | 194
@6 Широкий Прямоугольник  | 195

@@ @6 Включение Точки  | 192
@@ @6 Пересечение с Прямоугольником  | 193

